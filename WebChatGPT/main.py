#!/usr/bin/python
import requests
from WebChatGPT import utils
import logging

# from common_requests import request_headers, request_payload, request_cookies
import json
import re


class ChatGPT:
    def __init__(
        self,
        authorization: str,
        cookie_path: str,
        model: str = "text-davinci-002-render-sha",
        conversation_index: int = 0,
    ):
        """Initialize ChatGPT

        Args:
            authorization (str): OpenAI's authorization value
            cookie_path (str): Path to `.json` file containing `chat.openai.com` cookies
            model (str, optional): ChatGPT text generation model name. Defaults to "text-davinci-002-render-sha".
            conversation_index (int, optional): Conversation index to pick up conversation from. Defaults to 0.
        """
        self.session = requests.Session()
        self.session.headers.update(utils.get_request_headers(authorization))
        self.session.cookies.update(utils.get_cookies(cookie_path))
        self.conversation_endpoint = "https://chat.openai.com/backend-api/conversation"
        self.account_detail_endpoint = (
            "https://chat.openai.com/backend-api/accounts/check"
        )
        self.account_details_endpoint = self.account_detail_endpoint + "/v4-2023-04-27"
        self.prompt_library_endpoint = (
            "https://chat.openai.com/backend-api/prompt_library/"
        )
        self.previous_conversations_endpoint = (
            "https://chat.openai.com/backend-api/conversations"
        )
        self.title_generation_endpoint = "https://chat.openai.com/backend-api/conversation/gen_title/%(conversation_id)s"
        self.suggestions = (
            []
        )  # [prompt['title'] for prompt in self.prompt_library()['items'] ] # Generated by ChatGPT
        self.conversation_metadata = self.previous_conversations(
            index=conversation_index
        )
        self.model = model
        self.last_response = {}
        self.last_response_metadata = {}

    def __generate_payload(self, prompt: str) -> dict:
        resp = utils.generate_payload(self, prompt)
        return resp

    def ask(self, prompt: str, stream: bool = False) -> dict:
        """Chat with ChatGPT

                Args:
                    prompt (str): message to be send
                    stream (bool, optional): Flag to stream response. Defaults to False.
                returns : dict {}
        ```json
        {
            "message": {
                "id": "2c98d9ff-495c-4f08-af9e-affbd17xxxxx",
                "author": {
                    "role": "assistant",
                    "name": null,
                    "metadata": {}
                },
                "create_time": 1702666802.823688,
                "update_time": null,
                "content": {
                    "content_type": "text",
                    "parts": [
                        "Of course, your privacy matters! I don't store or remember our conversations once they're completed, so your information is kept confidential. If there's anything specific you'd like to discuss or if you have any concerns, feel free to let me know. I'm here to assist you!"
                    ]
                },
                "status": "finished_successfully",
                "end_turn": true,
                "weight": 1.0,
                "metadata": {
                    "finish_details": {
                        "type": "stop",
                        "stop_tokens": [
                            100260
                        ]
                    },
                    "inline_gizmo_id": null,
                    "is_complete": true,
                    "message_type": "next",
                    "model_slug": "text-davinci-002-render-sha",
                    "parent_id": "7bf27013-a47a-438c-ae17-0ee846b4xxxx",
                    "timestamp_": "absolute"
                },
                "recipient": "all"
            },
            "conversation_id": "affdda8c-588c-4342-9869-26c5bd7xxxxx",
            "error": null
        }
        ```
        """
        response = self.session.post(
            url=self.conversation_endpoint, json=self.__generate_payload(prompt)
        )
        if (
            response.ok
            and response.headers.get("content-type")
            == "text/event-stream; charset=utf-8"
        ):
            for chunk in response.iter_lines(
                decode_unicode=True,
            ):
                # Help me fix this stuff here, to stream response as per requirements

                # if not bool(chunk) or chunk=="data [DONE]":
                #   continue
                try:
                    if not bool(chunk):
                        continue
                    resp = json.loads(re.sub("data: ", "", chunk, 1).strip())
                    # print(resp)
                    if (
                        not "message_id" in resp.keys()
                        and "message" in resp.keys()
                        and resp["message"]["status"] == "finished_successfully"
                        and resp["message"]["end_turn"] == True
                    ):
                        self.last_response = resp
                        return resp
                    elif "message_id" in resp.keys():
                        self.last_response_metadata = resp

                    # if stream:
                    #   # Response to user
                    #  yield resp
                except json.decoder.JSONDecodeError as e:
                    # Could not be that serious
                    # print(chunk, "ERROR")
                    pass

        else:
            raise Exception(
                f"Failed to fetch response - ({response.status_code}, {response.reason} : {response.headers.get('content-type')} : {response.text}"
            )

    def chat(self, prompt: str, stream: bool = False) -> str:
        """Interact with ChatGPT on the fly

        Args:
            prompt (str): Message to ChatGPT
            stream (bool, optional): Yield the text response. Defaults to False.

        Returns:
            str: Text response generated

        Yields:
            Iterator[str]: Text response generated
        """
        resp = self.ask(prompt, stream)
        if isinstance(resp, dict):
            return utils.get_message(resp)
        else:
            # streaming response
            for response in resp:
                pass  #  To be fixed
                # yield utils.get_message(response)

    def user_details(self, in_details: bool = True) -> dict:
        """Returns various information concerning the user

                Args:
                    in_details (bool, optional): Return detailed info. Defaults to True.
                returns:
                    dict : {}
        ```json
        {
             "accounts": {
                  "b8a156d7-9a30-4de3-bf40-4d88782950c1": {
                       "account": {
                            "account_user_role": "account-owner",
                            "account_user_id": "user-IUW2uKHQ6bwv4bdiI8IYtjqA__b8a156d7-9a30-4de3-bf40-4d88782950c1",
                            "processor": {
                                 "a001": {
                                      "has_customer_object": false
                                 },
                                 "b001": {
                                      "has_transaction_history": false
                                 },
                                 "c001": {
                                      "has_transaction_history": false
                                 }
                            },
                            "account_id": "b8a156d7-9a30-4de3-bf40-4d88782950c1",
                            "organization_id": null,
                            "is_most_recent_expired_subscription_gratis": false,
                            "has_previously_paid_subscription": false,
                            "name": null,
                            "profile_picture_id": null,
                            "profile_picture_url": null,
                            "structure": "personal",
                            "plan_type": "free",
                            "is_deactivated": false,
                            "promo_data": {}
                       },
                       "features": [
                            "allow_url_thread_creation",
                            "arkose_enabled",
                            "arkose_gpt_35_experiment",
                            "bizmo_settings",
                            "breeze_available",
                            "chat_preferences_available",
                            "conversation_bot_arkose",
                            "disable_team_upgrade_ui",
                            "gizmo_live",
                            "gizmo_ui",
                            "invite_referral",
                            "new_plugin_oauth_endpoint",
                            "privacy_policy_nov_2023",
                            "shareable_links",
                            "starter_prompts",
                            "user_settings_announcements"
                       ],
                       "entitlement": {
                            "subscription_id": null,
                            "has_active_subscription": false,
                            "subscription_plan": "chatgptfreeplan",
                            "expires_at": null
                       },
                       "last_active_subscription": {
                            "subscription_id": null,
                            "purchase_origin_platform": "chatgpt_not_purchased",
                            "will_renew": false
                       }
                  },
                  "default": {
                       "account": {
                            "account_user_role": "account-owner",
                            "account_user_id": "user-IUW2uKHQ6bwv4bdiI8IYtjqA__b8a156d7-9a30-4de3-bf40-xxxxxxxxxx",
                            "processor": {
                                 "a001": {
                                      "has_customer_object": false
                                 },
                                 "b001": {
                                      "has_transaction_history": false
                                 },
                                 "c001": {
                                      "has_transaction_history": false
                                 }
                            },
                            "account_id": "b8a156d7-9a30-4de3-bf40-4d887829xxxx",
                            "organization_id": null,
                            "is_most_recent_expired_subscription_gratis": false,
                            "has_previously_paid_subscription": false,
                            "name": null,
                            "profile_picture_id": null,
                            "profile_picture_url": null,
                            "structure": "personal",
                            "plan_type": "free",
                            "is_deactivated": false,
                            "promo_data": {}
                       },
                       "features": [
                            "allow_url_thread_creation",
                            "arkose_enabled",
                            "arkose_gpt_35_experiment",
                            "bizmo_settings",
                            "breeze_available",
                            "chat_preferences_available",
                            "conversation_bot_arkose",
                            "disable_team_upgrade_ui",
                            "gizmo_live",
                            "gizmo_ui",
                            "invite_referral",
                            "new_plugin_oauth_endpoint",
                            "privacy_policy_nov_2023",
                            "shareable_links",
                            "starter_prompts",
                            "user_settings_announcements"
                       ],
                       "entitlement": {
                            "subscription_id": null,
                            "has_active_subscription": false,
                            "subscription_plan": "chatgptfreeplan",
                            "expires_at": null
                       },
                       "last_active_subscription": {
                            "subscription_id": null,
                            "purchase_origin_platform": "chatgpt_not_purchased",
                            "will_renew": false
                       }
                  }
             },
             "account_ordering": [
                  "b8a156d7-9a30-4de3-bf40-4d88782xxxx"
             ]
        }
        ```
        """
        resp = self.session.get(
            self.account_details_endpoint
            if in_details
            else self.account_detail_endpoint
        )
        return utils.is_json(resp, "account data")

    def prompt_library(self, limit: int = 4, offset: int = 0) -> list:
        """Generates random prompts

                Args:
                    limit (int, optional): Limit suggestions. Defaults to 4.
                    offset (int, optional): Offset. Defaults to 0.
                returns:
                    list : []

        ```json
           {
            "items": [
                {
                    "id": "edb56594",
                    "title": "Design a database schema",
                    "description": "for an online merch store",
                    "prompt": "Design a database schema for an online merch store."
                },
                {
                    "id": "9fa376de",
                    "title": "Recommend a dish",
                    "description": "to impress a date who's a picky eater",
                    "prompt": "I'm going to cook for my date who claims to be a picky eater. Can you recommend me a dish that's easy to cook?"
                }
            ],
            "total": 2,
            "limit": 2,
            "offset": 1
            }
        ```
        """

        resp = self.session.get(
            self.prompt_library_endpoint,
            params={"limit": limit, "offset": offset},
        )
        return utils.is_json(resp, "prompts")

    def previous_conversations(
        self,
        limit: int = 10,
        offset: int = 0,
        order: str = "updated",
        index: int = 0,
        all: str = False,
    ) -> list:
        """Loads previous conversations

                Args:
                    limit (int, optional): Fetch this specific amount of chats. Defaults to 28.
                    offset (int, optional): ``. Defaults to 0.
                    order (str, optional): Sort order. Defaults to "updated".
                    index (int, optional): Return items of this index. Defaults to 0.
                    all (bool, optional): Return the specified limit convos

                Returns:
                    list: Previous conversations contained in dict

                ```json
                {
             "items": [
                  {
                       "id": "86f73b54-0f51-47ba-84a3-07c1e25xxxx",
                       "title": "Urine Cleaning in Rome",
                       "create_time": "2023-12-15T13:39:24.683876+00:00",
                       "update_time": "2023-12-15T14:02:23.776574+00:00",
                       "mapping": null,
                       "current_node": null,
                       "conversation_template_id": null,
                       "gizmo_id": null,
                       "is_archived": false,
                       "workspace_id": null
                  },
                  {
                       "id": "b3779121-8767-4202-9527-3058f40xxxx",
                       "title": "Helpful User, Assistant",
                       "create_time": "2023-12-15T12:03:30.596706+00:00",
                       "update_time": "2023-12-15T13:29:05.286457+00:00",
                       "mapping": null,
                       "current_node": null,
                       "conversation_template_id": null,
                       "gizmo_id": null,
                       "is_archived": false,
                       "workspace_id": null
                  }
             ],
             "total": 108,
             "limit": 2,
             "offset": 0,
             "has_missing_conversations": false
           }
        ```
        """
        assert isinstance(index, int), "Index must be an integer"
        resp = self.session.get(
            self.previous_conversations_endpoint,
            params={"limit": limit, "offset": offset, "order": order},
        )
        resp = utils.is_json(resp, "conversation history")
        if all:
            return resp
        conversations = resp["items"]
        # conversations.reverse()
        if len(conversations) - 1 >= index:
            return conversations[index]
        else:
            raise Exception(
                f"Index '{index} is greater than the total conversations '{len(conversations)}"
            )

    def generate_title(self, conversation_id: str, message_id: str) -> dict:
        """Generate response for a particular conversation message

        Args:
            conversation_id (str): ``
            message_id (str): ``

        Returns:
            dict: ``
        """
        resp = self.session.post(
            self.title_generation_endpoint % {"conversation_id": conversation_id},
            json={"message_id": message_id},
        )
        resp = utils.is_json(resp, "title")
        return resp
